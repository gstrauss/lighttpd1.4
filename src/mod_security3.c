/*
 * mod_security3 - libmodsecurity integration for lighttpd
 *
 * Copyright(c) 2022 Glenn Strauss gstrauss()gluelogic.com  All rights reserved
 * License: BSD 3-clause (same as lighttpd)
 *
 *
 * mod_security3 makes libmodsecurity available as a lighttpd module
 * and does so without requiring any changes to lighttpd internals.
 *
 * Reasonable care and attention to detail must be taken by admin to configure
 * lighttpd.conf and to test scenarios in order to verify desired behavior.
 *
 * e.g.
 * - mod_security3 should be listed early in lighttpd.conf server.modules
 * - If ("respbody"=>"enable"), mod_security3 must precede mod_deflate
 * - If ("prereq-auth"=>"enable"), mod_security3 should be listed
 *   *after* mod_auth and *before* mod_fastcgi or other dynamic handlers
 *
 * LIMITATION: mod_security3 is not currently fed HTTP 1xx responses
 * and therefore does not evaluate headers of 1xx response headers.
 * This is low risk for 1xx responses generated by lighttpd.
 * However, 1xx responses generated by backends (e.g. 103 Early Hints)
 * might be abused to send response headers with arbitrary values.
 * As a mitigation, lighttpd provides configuration options to discard
 * 1xx responses from backends for use if that cost is an acceptable
 * tradeoff and does not break required site functionality:
 *   server.feature-flags += (
 *     "server.h2-discard-backend-1xx" => "enable"
 *     "server.h1-discard-backend-1xx" => "enable"
 *   )
 */
#include "first.h"

#include "base.h"
#include "log.h"
#include "buffer.h"
#include "fdevent.h"
#include "http_header.h"
#include "http_kv.h"
#include "request.h"
#include "response.h"
#include "plugin.h"

#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>     /* close() */

#include <modsecurity/modsecurity.h>
#include <modsecurity/transaction.h>
#include <modsecurity/intervention.h>

#if defined(MODSECURITY_CHECK_VERSION)
#if MODSECURITY_VERSION_NUM >= 304010
#define MSC_USE_RULES_SET 1
#endif
#endif
#if defined(MSC_USE_RULES_SET)
#include <modsecurity/rules_set.h>
#else
#include <modsecurity/rules.h>
typedef Rules RulesSet;
#endif

#define MSC_LIGHTTPD_CONNECTOR "ModSecurity-lighttpd v0.0.1"

typedef struct {
    uint8_t prereq_auth;
    uint8_t reqhdr;
    uint8_t reqbody;
    uint8_t resphdr;
    uint8_t respbody;
} modsec_opts;

typedef struct {
    const modsec_opts *opts;
    void *rules;
} plugin_config;

typedef struct {
    PLUGIN_DATA;
    plugin_config defaults;
    plugin_config conf;
    ModSecurity *ms;
} plugin_data;

typedef struct {
    Transaction *txn;
    const modsec_opts *opts;
    unsigned char *dptr;
    size_t dsz;
    request_st *r;
    ModSecurityIntervention it;
} handler_ctx;


static Transaction *
handler_ctx_init_txn (request_st * const r, plugin_data * const p,
                      RulesSet * const rules)
{
    /* use high-resolution timestamp to generate transaction unique id
     * Note: to have nanoseconds in id, lighttpd.conf must contain
     *   server.feature-flags += ("server.metrics-high-precision" => "enable")
     * (if high-resolution not otherwise enabled by mod_accesslog template) */
    buffer * const tb = r->tmp_buf;
    buffer_clear(tb);
    buffer_append_int(tb, r->start_hp.tv_sec*1000000000 + r->start_hp.tv_nsec);
    Transaction * const txn =
      msc_new_transaction_with_id(p->ms, rules, tb->ptr, r->conf.errh);
    if (txn) return txn;

    log_error(r->conf.errh, __FILE__, __LINE__,
      "modsecurity failed to initialize transaction");
    return NULL;
}


static handler_ctx *
handler_ctx_init (void)
{
    handler_ctx * const hctx = ck_calloc(1, sizeof(handler_ctx));
    hctx->it.status = 200;
    return hctx;
}


static void
handler_ctx_free (handler_ctx * const hctx)
{
    if (hctx->txn) {
        msc_process_logging(hctx->txn);
        msc_transaction_cleanup(hctx->txn);
    }
    free(hctx);
}


static void
mod_security3_log_cb (void *errh, const void *data)
{
    if (data)
        log_error(errh, __FILE__, __LINE__,
          "(modsecurity): %s", (const char *)data);
}


INIT_FUNC(mod_security3_init)
{
    return ck_calloc(1, sizeof(plugin_data));
}


FREE_FUNC(mod_security3_free)
{
    plugin_data * const p = p_d;
    if (p->ms) msc_cleanup(p->ms);
    if (NULL == p->cvlist) return;
    /* (init i to 0 if global context; to 1 to skip empty global context) */
    for (int i = !p->cvlist[0].v.u2[1], used = p->nconfig; i < used; ++i) {
        config_plugin_value_t *cpv = p->cvlist + p->cvlist[i].v.u2[0];
        for (; -1 != cpv->k_id; ++cpv) {
            switch (cpv->k_id) {
              case 0: /* modsecurity3.opts */
                if (cpv->vtype == T_CONFIG_LOCAL)
                    free(cpv->v.v);
                break;
              case 1: /* modsecurity3.rules */
                if (cpv->vtype == T_CONFIG_LOCAL && cpv->v.v)
                    msc_rules_cleanup(cpv->v.v);
                break;
              default:
                break;
            }
        }
    }
}


static void
mod_security3_merge_config_cpv (plugin_config * const pconf,
                                const config_plugin_value_t * const cpv)
{
    switch (cpv->k_id) { /* index into static config_plugin_keys_t cpk[] */
      case 0: /* modsecurity3.opts */
        if (cpv->vtype == T_CONFIG_LOCAL)
            pconf->opts = cpv->v.v;
        break;
      case 1: /* modsecurity3.rules */
        if (cpv->vtype == T_CONFIG_LOCAL)
            pconf->rules = cpv->v.v;
        break;
      default:/* should not happen */
        return;
    }
}


static void
mod_security3_merge_config (plugin_config * const pconf,
                            const config_plugin_value_t *cpv)
{
    do {
        mod_security3_merge_config_cpv(pconf, cpv);
    } while ((++cpv)->k_id != -1);
}


static void
mod_security3_patch_config (request_st * const r, plugin_data * const p)
{
    p->conf = p->defaults; /* copy small struct instead of memcpy() */
    for (int i = 1, used = p->nconfig; i < used; ++i) {
        if (config_check_cond(r, (uint32_t)p->cvlist[i].k_id))
            mod_security3_merge_config(&p->conf,p->cvlist+p->cvlist[i].v.u2[0]);
    }
}


static modsec_opts *
mod_security3_parse_opts (server * const srv, const array * const a)
{
    modsec_opts * const opts = ck_calloc(1, sizeof(modsec_opts));
    for (uint32_t i = 0; i < a->used; ++i) {
        data_unset * const du = a->data[i];
        const uint8_t v = config_plugin_value_tobool(du, 0);
        if (0 == strcmp(du->key.ptr, "prereq-auth"))
            opts->prereq_auth = v;
        else if (0 == strcmp(du->key.ptr, "reqhdr"))
            opts->reqhdr = v;
        else if (0 == strcmp(du->key.ptr, "reqbody"))
            opts->reqbody = v;
        else if (0 == strcmp(du->key.ptr, "request"))
            opts->reqhdr = opts->reqbody = v;
        else if (0 == strcmp(du->key.ptr, "resphdr"))
            opts->resphdr = v;
        else if (0 == strcmp(du->key.ptr, "respbody"))
            opts->respbody = v;
        else if (0 == strcmp(du->key.ptr, "response"))
            opts->resphdr = opts->respbody = v;
        else {
            log_error(srv->errh, __FILE__, __LINE__,
              "modsecurity3.opts unrecognized key: %s", du->key.ptr);
            free(opts);
            return NULL;
        }
    }
    return opts;
}


static RulesSet *
mod_security3_parse_rules (server * const srv, const array * const a)
{
    /* future: might keep a cache of file and remote (RulesSet *) and reuse with
     * msc_rules_merge() to avoid reloading when matching targets are reused
     * (cache could be self-contained here, and cleaned up before returning)*/
    RulesSet * const rules = msc_create_rules_set();
    char *err = NULL;
    for (uint32_t i = 0; i < a->used; ++i) {
        char * const v = ((data_string *)a->data[i])->value.ptr;
        int rc;
        if (*v == '/') /*(expect path)*/
            rc = msc_rules_add_file(rules, v, (const char **)&err);
        if (*v != ' ') /*(expect "Sec...")*/
            rc = msc_rules_add(rules, v, (const char **)&err);
        else { /* remotes start with space, e.g. " key url" */
            char *sp = strchr(v+1, ' ');
            if (sp) {
                *sp = '\0';
                rc = msc_rules_add_remote(rules,v+1,sp+1,(const char **)&err);
                *sp = ' ';
            }
            else {
                rc = -1;
                err = strdup("invalid syntax");
            }
        }

        if (rc < 0) {
            if (err) {
                log_error(srv->errh, __FILE__, __LINE__,
                  "modsecurity3.rules: %s: %s", v, err);
                free(err);
            }
            msc_rules_cleanup(rules);
            return NULL;
        }
    }
    return rules;
}


SETDEFAULTS_FUNC(mod_security3_set_defaults)
{
    static const config_plugin_keys_t cpk[] = {
      { CONST_STR_LEN("modsecurity3.opts"),
        T_CONFIG_ARRAY_KVANY,
        T_CONFIG_SCOPE_CONNECTION }
     ,{ CONST_STR_LEN("modsecurity3.rules"),
        T_CONFIG_ARRAY_VLIST,
        T_CONFIG_SCOPE_CONNECTION }
     ,{ NULL, 0,
        T_CONFIG_UNSET,
        T_CONFIG_SCOPE_UNSET }
    };

    plugin_data * const p = p_d;
    if (!config_plugin_values_init(srv, p, cpk, "mod_security3"))
        return HANDLER_ERROR;

    /* process and validate config directives
     * (init i to 0 if global context; to 1 to skip empty global context) */
    for (int i = !p->cvlist[0].v.u2[1]; i < p->nconfig; ++i) {
        config_plugin_value_t *cpv = p->cvlist + p->cvlist[i].v.u2[0];
        for (; -1 != cpv->k_id; ++cpv) {
            switch (cpv->k_id) {
              case 0: /* modsecurity3.opts */
                if (cpv->v.a->used == 0)
                    cpv->v.v = NULL;
                else {
                    cpv->v.v = mod_security3_parse_opts(srv, cpv->v.a);
                    if (NULL == cpv->v.v)
                        return HANDLER_ERROR;
                }
                cpv->vtype = T_CONFIG_LOCAL;
                break;
              case 1: /* modsecurity3.rules */
                if (cpv->v.a->used == 0)
                    cpv->v.v = NULL;
                else {
                    cpv->v.v = mod_security3_parse_rules(srv, cpv->v.a);
                    if (NULL == cpv->v.v)
                        return HANDLER_ERROR;
                }
                cpv->vtype = T_CONFIG_LOCAL;
                break;
              default:/* should not happen */
                break;
            }
        }
    }

    /* initialize p->defaults from global config context */
    if (p->nconfig > 0 && p->cvlist->v.u2[1]) {
        const config_plugin_value_t *cpv = p->cvlist + p->cvlist->v.u2[0];
        if (-1 != cpv->k_id)
            mod_security3_merge_config(&p->defaults, cpv);
    }

    /* attempt to warn if suboptimal module load ordering is detected */
    {
        uint32_t i;
        for (i = 0; i < srv->srvconf.modules->used; ++i) {
            data_string *ds = (data_string *)srv->srvconf.modules->data[i];
            if (buffer_eq_slen(&ds->value, CONST_STR_LEN("mod_deflate")))
                break;
        }
        for (; i < srv->srvconf.modules->used; ++i) {
            data_string *ds = (data_string *)srv->srvconf.modules->data[i];
            if (buffer_eq_slen(&ds->value, CONST_STR_LEN("mod_security3"))) {
                log_error(srv->errh, __FILE__, __LINE__,
                  "mod_security3 must be loaded before %s in server.modules",
                  ds->value.ptr);
                break;
            }
        }
    }

    p->ms = msc_init();
    force_assert(p->ms);
    msc_set_connector_info(p->ms, MSC_LIGHTTPD_CONNECTOR);
    msc_set_log_cb(p->ms, mod_security3_log_cb);

    return HANDLER_GO_ON;
}


__attribute_cold__
__attribute_noinline__
static int
mod_security3_hctx_dptr_malloc (handler_ctx * const hctx)
{
    hctx->dptr = malloc(hctx->dsz);
    if (NULL == hctx->dptr) {
        request_st * const r = hctx->r;
        log_perror(r->conf.errh, __FILE__, __LINE__, "malloc");
        http_response_reset(r);
        r->http_status = 500;
        return 0;
    }
    return 1;
}


__attribute_cold__
__attribute_noinline__
static int
mod_security3_disruptive (handler_ctx * const hctx)
{
    ModSecurityIntervention * const it = &hctx->it;
    request_st * const r = hctx->r;

    if (it->log) {
        log_error(r->conf.errh, __FILE__, __LINE__, "%s", it->log);
        free(it->log);
        it->log = NULL;
    }

    if (it->status == 200) /*(unexpected if disruptive is set)*/
        return 0;

    http_response_reset(r);
    r->http_status = it->status;
    it->status = 200;
    msc_update_status_code(hctx->txn, r->http_status);

    if (it->url) {
        buffer * const v =
          http_header_response_set_ptr(r, HTTP_HEADER_LOCATION,
                                       CONST_STR_LEN("Location"));
        if (v->ptr) free(v->ptr);
        v->ptr = it->url;
        it->url = NULL;
        v->used = v->size = strlen(v->ptr)+1;
    }

    return 1;
}


typedef int(msc_append_body_fn_t)(Transaction *transaction, const unsigned char *buf, size_t len);


static int
mod_security3_txn_append_cq_file (handler_ctx * const hctx,
                                  msc_append_body_fn_t msc_append_body_fn,
                                  const chunk * const c)
{
    /*(bypass msc_request_body_from_file() to avoid excess copying
     * and since func does not support file offset and length)*/
    /* response body might contain user-provided (untrusted) files,
     * so any future use of mmap should take appropriate precautions,
     * as well as having to handle files > 4 GB on 32-bit systems */
    /*(open/close fd locally if not already open; avoid holding excess
     * fd open as now might be different from later file consumption by
     * backend application or by client)*/
    /*(code similar to mod_deflate_file_chunk_no_mmap())*/
    const int fd = (-1 != c->file.fd)
      ? c->file.fd
      : fdevent_open_cloexec(c->mem->ptr, hctx->r->conf.follow_symlink,
                             O_RDONLY, 0);
    if (-1 == fd) {
        request_st * const r = hctx->r;
        log_perror(r->conf.errh, __FILE__, __LINE__,
          "open failed %s", c->mem->ptr);
        http_response_reset(r);
        r->http_status = 500;
        return -1;
    }

    int rc = 0;
    unsigned char * const dptr = hctx->dptr;
    const size_t dsz = hctx->dsz;
    ssize_t rd = 0;
    const off_t insz = c->file.length - c->offset;
    for (off_t n = 0; n < insz; n += rd) {
        rd = chunk_file_pread(fd, dptr, (size_t)dsz, c->offset+n);
        if (__builtin_expect( (rd > 0), 1)) {
            /* limitation: libmodsecurity rc == 0 does not distinguish
             * between error writing and partial body limit reached */
            rc = msc_append_body_fn(hctx->txn, dptr, (size_t)rd);
            if (msc_intervention(hctx->txn, &hctx->it)) {
                if (mod_security3_disruptive(hctx))
                    rc = -1;
            }
        }
        else {
            request_st * const r = hctx->r;
            if (-1 == rd)
                log_perror(r->conf.errh, __FILE__, __LINE__,
                  "reading %s failed", c->mem->ptr);
            else /*(0 == rd)*/
                log_error(r->conf.errh, __FILE__, __LINE__,
                  "file truncated %s", c->mem->ptr);
            http_response_reset(r);
            r->http_status = 500;
            rc = -1;
        }
        if (rc <= 0) break;
    }
    if (-1 == c->file.fd) close(fd);
    return rc;
}


static int
mod_security3_txn_append_cq (handler_ctx * const hctx,
                            msc_append_body_fn_t msc_append_body_fn,
                            chunkqueue * const cq)
{
    int rc = 0;
    off_t n = chunkqueue_length(cq);
    hctx->dsz = (n < 2*1024*1024) ? (size_t)n : 2*1024*1024;
    for (chunk *c = cq->first; c; c = c->next) {
        if (c->type == MEM_CHUNK) {
            /* limitation: libmodsecurity rc == 0 does not distinguish
             * between error writing and partial body limit reached */
            rc = msc_append_body_fn(hctx->txn,
                   (unsigned char *)c->mem->ptr + c->offset,
                   buffer_clen(c->mem) - c->offset);
            if (msc_intervention(hctx->txn, &hctx->it)) {
                if (mod_security3_disruptive(hctx))
                    rc = -1;
            }
        }
        else { /* if (c->type == FILE_CHUNK) */
            if (NULL == hctx->dptr && !mod_security3_hctx_dptr_malloc(hctx))
                return -1;
            rc = mod_security3_txn_append_cq_file(hctx, msc_append_body_fn, c);
        }
        if (rc <= 0) break;
    }
    if (hctx->dptr) {
        free(hctx->dptr);
        hctx->dptr = NULL;
    }
    return rc;
}


static handler_t
mod_security3_reqhdr (handler_ctx * const hctx, request_st * const r)
{
    /* process URI */
    /*(r->target_orig in case mod_rewrite changed uri before mod_security3)*/
    const buffer * const b = http_version_buf(r->http_version);
    const char * const http_version = buffer_clen(b) > 5
      ? b->ptr+5 /*(step over "HTTP/")*/
      : b->ptr;
    const buffer * const method = http_method_buf(r->http_method);
    msc_process_uri(hctx->txn, r->target_orig.ptr, method->ptr, http_version);
    if (msc_intervention(hctx->txn,&hctx->it) && mod_security3_disruptive(hctx))
        return HANDLER_FINISHED;

    /* add request headers */
    data_string * const * const restrict hdata =
      (data_string * const *)r->rqst_headers.data;
    for (uint32_t i = 0, used = r->rqst_headers.used; i < used; ++i) {
        const data_string * const ds = hdata[i];
        const uint32_t klen = buffer_clen(&ds->key);
        const uint32_t vlen = buffer_clen(&ds->value);
        if (__builtin_expect( (0 == klen), 0)) continue;
        if (__builtin_expect( (0 == vlen), 0)) continue;

        msc_add_n_request_header(hctx->txn,
          (const unsigned char *)ds->key.ptr, klen,
          (const unsigned char *)ds->value.ptr, vlen);
    }
  #if 0
    if (-1 == r->reqbody_length && r->http_version == HTTP_VERSION_1_1) {
        msc_add_n_request_header(hctx->txn,
          (const unsigned char *)CONST_STR_LEN("Transfer-Encoding"),
          (const unsigned char *)CONST_STR_LEN("chunked"));
    }
  #endif

    msc_process_request_headers(hctx->txn);
    if (msc_intervention(hctx->txn,&hctx->it) && mod_security3_disruptive(hctx))
        return HANDLER_FINISHED;

    return HANDLER_GO_ON;
}


static handler_t
mod_security3_reqbody (handler_ctx * const hctx, request_st * const r,
                       plugin_data * const p)
{
    chunkqueue * const cq = &r->reqbody_queue;
    if (chunkqueue_is_empty(cq))
        return HANDLER_GO_ON;
    if (cq->bytes_in == (off_t)r->reqbody_length) {
        if (mod_security3_txn_append_cq(hctx, msc_append_request_body, cq) < 0)
            return HANDLER_FINISHED;
        msc_process_request_body(hctx->txn);
        if (msc_intervention(hctx->txn, &hctx->it)) {
            if (mod_security3_disruptive(hctx))
                return HANDLER_FINISHED;
        }
    }
    else if (NULL == r->handler_module) {
        /* disable request body streaming and set up handler to collect body */
        r->conf.stream_request_body &=
          ~(FDEVENT_STREAM_REQUEST|FDEVENT_STREAM_REQUEST_BUFMIN);
        r->handler_module = p->self;
    }
    else {
        log_error(r->conf.errh, __FILE__, __LINE__,
          "unable to collect request body (handler already set); "
          "(perhaps load mod_security3 earlier in server.modules, "
          "before mod_%s)", r->handler_module->name);
    }

    return HANDLER_GO_ON;
}


static handler_t
mod_security3_resphdr (handler_ctx * const hctx, request_st * const r)
{
    /* add response headers */
    const int resp_header_repeated = r->resp_header_repeated;
    data_string * const * const restrict hdata =
      (data_string * const *)r->resp_headers.data;
    for (uint32_t i = 0, used = r->resp_headers.used; i < used; ++i) {
        const data_string * const ds = hdata[i];
        const uint32_t klen = buffer_clen(&ds->key);
        const uint32_t vlen = buffer_clen(&ds->value);
        if (__builtin_expect( (0 == klen), 0)) continue;
        if (__builtin_expect( (0 == vlen), 0)) continue;

        if (__builtin_expect( (ds->ext == HTTP_HEADER_OTHER), 0)
            && (*ds->key.ptr & 0xdf) == 'X'
            && http_response_omit_header(r, ds)) {
            continue;
        }

        /* XXX: must field-name (key) be lowercased for libmodsecurity
         *      if (r->http_version == HTTP_VERSION_2) ? */

        uint32_t voff = 0, vpart;
        const char *n;
        do {
            const char *v = ds->value.ptr+voff;
            n = !resp_header_repeated ? NULL : memchr(v, '\n', vlen - voff);

            if (NULL == n)
                vpart = vlen - voff;
            else {
                /* multiple headers (same field-name) separated by "\r\n"
                 * and then "field-name: " (see http_header_response_insert())*/
                uint32_t noff = (uint32_t)(n + 1 - ds->value.ptr);
                vpart = noff - 2 - voff; /*(-2 for "\r\n")*/
                voff = noff + klen + 2;
            }

            msc_add_n_response_header(hctx->txn,
              (const unsigned char *)ds->key.ptr, klen,
              (const unsigned char *)v, vpart);
        } while (n);
    }
  #if 0 /*(skip unnecessary work)*/
    if (!light_btst(r->resp_htags, HTTP_HEADER_DATE)) {
        static char tstr[30];
        http_date_time_to_str(tstr, sizeof(tstr), log_epoch_secs);
        msc_add_n_response_header(hctx->txn,
          (const unsigned char *)CONST_STR_LEN("date"),
          (const unsigned char *)tstr, 29);
    }
    if (!light_btst(r->resp_htags, HTTP_HEADER_SERVER) && r->conf.server_tag) {
        msc_add_n_response_header(hctx->txn,
          (const unsigned char *)CONST_STR_LEN("server"),
          (const unsigned char *)BUF_PTR_LEN(r->conf.server_tag));
    }
  #endif
    if (light_btst(r->resp_htags, HTTP_HEADER_UPGRADE)
        && r->http_version == HTTP_VERSION_1_1) {
        msc_add_n_response_header(hctx->txn,
          (const unsigned char *)CONST_STR_LEN("Connection"),
          (const unsigned char *)CONST_STR_LEN("upgrade"));
    } /*(not bothering to check,generate "keep-alive" or "close" for HTTP/1.x)*/

    buffer * const tb = r->tmp_buf;
    buffer_clear(tb);
    http_version_append(tb, r->http_version);
    tb->ptr[4] = ' '; /* e.g. "HTTP 1.1" instead of "HTTP/1.1" */
    msc_process_response_headers(hctx->txn, r->http_status, tb->ptr);
    if (msc_intervention(hctx->txn,&hctx->it) && mod_security3_disruptive(hctx))
        return HANDLER_FINISHED;

    return HANDLER_GO_ON;
}


static handler_t
mod_security3_respbody (handler_ctx * const hctx, request_st * const r)
{
    if (!r->resp_body_finished)
        /*(response streaming is disabled in mod_security3_handle_uri())*/
        log_error(r->conf.errh, __FILE__, __LINE__,
          "unexpected incomplete response body");
    chunkqueue * const cq = &r->write_queue;
    if (chunkqueue_is_empty(cq))
        return HANDLER_GO_ON;
    if (mod_security3_txn_append_cq(hctx, msc_append_response_body, cq) < 0)
        return HANDLER_FINISHED;
    msc_process_response_body(hctx->txn);
    if (msc_intervention(hctx->txn,&hctx->it) && mod_security3_disruptive(hctx))
        return HANDLER_FINISHED;
    return HANDLER_GO_ON;
}


static handler_t
mod_security3_addr (handler_ctx * const hctx, request_st * const r)
{
    /* Note: this is currently run after HTTP request headers are received.
     * If libmodsecurity addr rules should run earlier, add connection_accept
     * hook and create temporary transaction there just to check address. */
    /* libmodsecurity could be improved to share structure with connection info
     * so that this does not needed be repeated for each request on connection*/
    connection * const con = r->con;
    /*(note: not calling getsockname() on wildcard addr and stringifying)*/
    buffer * const tb = r->tmp_buf;
    const server_socket * const srv_sock = con->srv_socket;
    if (!sock_addr_is_addr_wildcard(&con->dst_addr))
        buffer_copy_string_len(tb, srv_sock->srv_token->ptr,
                                   srv_sock->srv_token_colon);
    else if (sock_addr_get_family(&con->dst_addr) == AF_INET6)
        buffer_copy_string_len(tb, CONST_STR_LEN("::"));
    else /* AF_INET */
        buffer_copy_string_len(tb, CONST_STR_LEN("0.0.0.0"));
    int cport = sock_addr_get_port(&con->dst_addr);
    int sport = sock_addr_get_port(&srv_sock->addr);
    const char * const caddr = con->dst_addr_buf.ptr;
    msc_process_connection(hctx->txn, caddr, cport, tb->ptr, sport);
    if (msc_intervention(hctx->txn,&hctx->it) && mod_security3_disruptive(hctx))
        return HANDLER_FINISHED;
    return HANDLER_GO_ON;
}


URIHANDLER_FUNC(mod_security3_handle_uri)
{
    /* Do not repeat security checks on headers for same request, e.g. after
     * HANDER_COMEBACK from mod_rewrite, mod_magnet MAGNET_RESTART_REQUEST,
     * mod_cgi cgi.local-redir, gw_backend reconnect, or mod_security3
     * collecting request body. */
    plugin_data *p = p_d;
    void ** const restrict pctx = &r->plugin_ctx[p->id];
    handler_ctx *hctx = *pctx;
    const modsec_opts *opts;
    if (hctx != NULL)
        opts = hctx->opts;
    else {
        mod_security3_patch_config(r, p);
        opts = p->conf.opts;
        if (NULL == opts) return HANDLER_GO_ON;
        RulesSet * const rules = p->conf.rules;
        if (NULL == rules) return HANDLER_GO_ON;

        if (opts->prereq_auth) {
            if (NULL == http_header_env_get(r, CONST_STR_LEN("REMOTE_USER")))
                return HANDLER_GO_ON;
        }

        Transaction * const txn = handler_ctx_init_txn(r, p, rules);
        if (!txn)
            return HANDLER_GO_ON; /*(failed to init; allow request; fail open)*/

        *pctx = hctx = handler_ctx_init();
        hctx->r = r;
        hctx->opts = opts;
        hctx->txn = txn;

        handler_t rc;
        rc = mod_security3_addr(hctx, r);
        if (HANDLER_GO_ON != rc) return rc;

        if (opts->reqhdr) {
            rc = mod_security3_reqhdr(hctx, r);
            if (HANDLER_GO_ON != rc) return rc;
        }
    }

    if (opts->respbody)
        /* disable response body streaming to collect response body */
        r->conf.stream_response_body &=
          ~(FDEVENT_STREAM_RESPONSE|FDEVENT_STREAM_RESPONSE_BUFMIN);

    return (opts->reqbody)
      ? mod_security3_reqbody(hctx, r, p)
      : HANDLER_GO_ON;
}


SUBREQUEST_FUNC(mod_security3_handle_subrequest)
{
    /* read entire request body from network and then restart request */
    UNUSED(p_d);

    if (r->state == CON_STATE_READ_POST) {
        /*(streaming flags removed when mod_security3 installed this handler)*/
        handler_t rc = r->con->reqbody_read(r);
        if (rc != HANDLER_GO_ON) return rc;
        if (r->state == CON_STATE_READ_POST)
            return HANDLER_WAIT_FOR_EVENT;
    }

    buffer_clear(&r->physical.path);
    r->handler_module = NULL;
    return HANDLER_COMEBACK;
}


URIHANDLER_FUNC(mod_security3_handle_response_start)
{
    void ** const restrict pctx =
      &r->plugin_ctx[((plugin_data *)p_d)->id];
    handler_ctx * const hctx = *pctx;
    if (NULL == hctx) return HANDLER_GO_ON;

    const modsec_opts * const opts = hctx->opts;
    handler_t rc = HANDLER_GO_ON;

    if (opts->resphdr) {
        rc = mod_security3_resphdr(hctx, r);
        if (HANDLER_GO_ON != rc) return rc;
    }

    if (opts->respbody)
        rc = mod_security3_respbody(hctx, r);

    /* optional early resource cleanup: mod_security3_handle_reset(r, p_d); */
    handler_ctx_free(hctx);
    *pctx = NULL;
    return rc;
}


REQUEST_FUNC(mod_security3_handle_reset)
{
    void ** const restrict dptr =
      &r->plugin_ctx[((plugin_data *)p_d)->id];
    if (*dptr) {
        handler_ctx_free(*dptr);
        *dptr = NULL;
    }
    return HANDLER_GO_ON;
}


int mod_security3_plugin_init (plugin *p);
int mod_security3_plugin_init (plugin *p) {
    p->version = LIGHTTPD_VERSION_ID;
    p->name    = "security3";

    p->handle_uri_clean         = mod_security3_handle_uri;
    p->handle_subrequest        = mod_security3_handle_subrequest;
    p->handle_response_start    = mod_security3_handle_response_start;
    p->handle_request_reset     = mod_security3_handle_reset;
    p->init                     = mod_security3_init;
    p->set_defaults             = mod_security3_set_defaults;
    p->cleanup                  = mod_security3_free;

    return 0;
}
